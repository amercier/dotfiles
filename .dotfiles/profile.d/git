#!/usr/bin/env sh

# Push commits of a branch one after another
# @param [1] Remote name
# @param [2] Remote branch
git_push_all() {
  if [ "$#" = 0 ]
  then
    remote="$(git rev-parse --abbrev-ref --symbolic-full-name '@{u}' 2>/dev/null)"
    if [ -z "$remote" ]
    then
      echo "Not connected to a remote" >&2
      return 1
    fi
    remote_name=$(echo "$remote" | grep -E -o '^[^/]+')
    remote_branch=$(echo "$remote" | grep -E -o '[^/]+$')
  elif [ "$#" = 2 ]
  then
    remote_name="$1"
    remote_branch="$2"
  else
    echo "Syntax: git_push_all or git_push_all REMOTE BRANCH" >&2
    return 1
  fi

  git rev-list --reverse "${remote_name}/${remote_branch}..HEAD" --abbrev-commit | while read -r sha
  do
    echo "Pushing commit $(cyan "${sha}")..."
    command="git push ${remote_name} ${sha}:${remote_branch}"
    if eval "$command"
    then
      green "✓ Done\\n\\n"
    else
      echo "$(red "✗ Failed to push commit ${sha}.") Try:" 2>&1
      echo "$command -f" 2>&1
      return 1
    fi
  done
}

# Force-push a commit to the current remote branch.
# @param [1] Commit, defaults to HEAD
git_rework() {
  commit=${1-HEAD}
  branch=$(git current-remote)
  if [ "$(git rev-parse --short "$branch")" = "$(git rev-parse --short "$commit")" ]
  then
    echo "Branch $(cyan "$branch") is already at $(magenta "$(git rev-parse --short "$branch")"), aborting." >&2
    return 1
  fi

  echo "Reworking $(magenta "$(git rev-parse --short "$branch")") -> $(magenta "$(git rev-parse --short "$commit")") to $(cyan "$branch"):"
  git log --pretty=friendly "$branch" --not "$commit" --no-color | while read -r line; do
    red "- $line\\n"
  done
  git log --pretty=friendly "HEAD" --not "$commit" --no-color | while read -r line; do
    black "* $line\\n"
  done
  git log --pretty=friendly "$commit" --not "$branch" --no-color | while read -r line; do
    green "+ $line\\n"
  done
  git log -2 --pretty=friendly "$(git merge-base "$commit" "$branch")" | tail -n 3 | while read -r line; do
    echo "  $line"
  done
  command="git push $(echo "$branch" | tr / '\n' | head -n 1) $commit:$(echo "$branch" | tr / '\n' | tail -n 1) -f"
  echo
  while
    printf "Proceed with: %s ? [y/n] " "$(yellow "$command")" && read -r answer
  do
    case $answer in
      [Yy]* ) $command; return 0;;
      [Nn]* ) echo "Aborted." >&2; return 1;;
      * ) echo "Please enter 'y' or 'n'.";;
    esac
  done
}

alias g=git
alias ga='git add'
alias gaa='git add .'
alias gaac='git add . && git commit-message'
alias gaam='git add . && git amend'
alias gc='git commit-message'
alias gd='git diff'
alias gdc='git diff-cached'
alias gf='git forked'
alias gff='git forked | head -n 10'
alias gh='git show'
alias ghf='git show-files'
alias gl='git graph'
alias gll='git graph | head -n 10'
alias gm='git amend'
alias gp='git push'
alias gpa='git push-all'
alias gpf='git push -f'
alias gpu='git push-upstream'
alias gr='git rework'
alias gs='git status --short'
alias gu='git pull'
